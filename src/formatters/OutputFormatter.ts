/**
 * Output format converters for filter lists.
 * Converts adblock-style rules to various output formats.
 */

import { OutputFormat } from '../config/defaults.ts';
import { RuleUtils } from '../utils/RuleUtils.ts';
import { PACKAGE_INFO } from '../version.ts';

/**
 * Options for output formatting
 */
export interface FormatterOptions {
    /** Include header comments */
    includeHeader?: boolean;
    /** Filter list name for headers */
    listName?: string;
    /** IP address to use for hosts format (default: 0.0.0.0) */
    hostsIp?: string;
    /** Include localhost entries in hosts format */
    includeLocalhost?: boolean;
}

/**
 * Result of formatting operation
 */
export interface FormatterResult {
    /** Formatted content as string */
    content: string;
    /** Number of rules included */
    ruleCount: number;
    /** Number of rules skipped (not convertible) */
    skippedCount: number;
    /** Output format used */
    format: OutputFormat;
}

/**
 * Base class for output formatters.
 * Extend this class to create custom output formatters.
 */
export abstract class BaseFormatter {
    /** Formatter options */
    protected readonly options: FormatterOptions;

    /**
     * Creates a new formatter
     * @param options - Formatter options
     */
    constructor(options?: FormatterOptions) {
        this.options = {
            includeHeader: true,
            listName: 'Filter List',
            hostsIp: '0.0.0.0',
            includeLocalhost: false,
            ...options,
        };
    }

    /**
     * Formats rules to the target format
     */
    abstract format(rules: string[]): FormatterResult;

    /**
     * Extracts hostname from an adblock rule
     */
    protected extractHostname(rule: string): string | null {
        // Skip comments and empty lines
        if (!rule || rule.startsWith('!') || rule.startsWith('#')) {
            return null;
        }

        // Skip exception rules
        if (rule.startsWith('@@')) {
            return null;
        }

        // Try to parse as adblock rule
        try {
            const parsed = RuleUtils.loadAdblockRuleProperties(rule);
            if (parsed.hostname && !parsed.whitelist) {
                return parsed.hostname;
            }
        } catch {
            // Not a valid adblock rule
        }

        // Check if it's a plain domain
        if (RuleUtils.isJustDomain(rule)) {
            return rule;
        }

        // Try to extract from simple patterns
        const match = rule.match(/^\|\|([a-z0-9.-]+)\^?$/i);
        if (match) {
            return match[1];
        }

        return null;
    }

    /**
     * Generates a header comment
     */
    protected generateHeader(commentPrefix: string): string[] {
        const lines = [
            `${commentPrefix} ${this.options.listName}`,
            `${commentPrefix} Generated by ${PACKAGE_INFO.name} v${PACKAGE_INFO.version}`,
            `${commentPrefix} Last updated: ${new Date().toISOString()}`,
            '',
        ];
        return lines;
    }
}

/**
 * Formats rules to /etc/hosts format
 */
export class HostsFormatter extends BaseFormatter {
    /**
     * Formats rules to hosts file format
     * @param rules - Array of rules to format
     * @returns Formatter result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        // Add localhost entries if requested
        if (this.options.includeLocalhost) {
            lines.push('127.0.0.1 localhost');
            lines.push('::1 localhost');
            lines.push('');
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`${this.options.hostsIp} ${hostname}`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Hosts,
        };
    }
}

/**
 * Formats rules to dnsmasq format
 */
export class DnsmasqFormatter extends BaseFormatter {
    /**
     * Formats rules to dnsmasq format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`address=/${hostname}/`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Dnsmasq,
        };
    }
}

/**
 * Formats rules to Pi-hole format (domain list)
 */
export class PiHoleFormatter extends BaseFormatter {
    /**
     * Formats rules to Pi-hole domain list format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(hostname);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.PiHole,
        };
    }
}

/**
 * Formats rules to Unbound DNS resolver format
 */
export class UnboundFormatter extends BaseFormatter {
    /**
     * Formats rules to Unbound DNS resolver format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        lines.push('server:');

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`    local-zone: "${hostname}" always_nxdomain`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Unbound,
        };
    }
}

/**
 * Formats rules to JSON format
 */
export class JsonFormatter extends BaseFormatter {
    /**
     * Formats rules to JSON format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const hostnames: string[] = [];
        const allRules: string[] = [];
        let skippedCount = 0;

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            if (!rule || rule.startsWith('!')) {
                continue;
            }

            allRules.push(rule);

            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                hostnames.push(hostname);
            } else if (hostname === null) {
                skippedCount++;
            }
        }

        const output = {
            name: this.options.listName,
            generated: new Date().toISOString(),
            generator: `${PACKAGE_INFO.name} v${PACKAGE_INFO.version}`,
            stats: {
                totalRules: allRules.length,
                uniqueHostnames: hostnames.length,
                skippedRules: skippedCount,
            },
            hostnames,
            rules: allRules,
        };

        return {
            content: JSON.stringify(output, null, 2),
            ruleCount: hostnames.length,
            skippedCount,
            format: OutputFormat.JSON,
        };
    }
}

/**
 * Formats rules to DNS-over-HTTPS blocklist format
 */
export class DoHFormatter extends BaseFormatter {
    /**
     * Formats rules to DNS-over-HTTPS blocklist format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                // DoH format: simple domain list, one per line
                lines.push(hostname);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.DoH,
        };
    }
}

/**
 * Adblock format passthrough (no conversion)
 */
export class AdblockFormatter extends BaseFormatter {
    /**
     * Formats rules in adblock format (passthrough)
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        return {
            content: rules.join('\n'),
            ruleCount: rules.filter((r) => r && !r.startsWith('!')).length,
            skippedCount: 0,
            format: OutputFormat.Adblock,
        };
    }
}

/**
 * Factory function to create formatters
 */
export function createFormatter(format: OutputFormat, options?: FormatterOptions): BaseFormatter {
    switch (format) {
        case OutputFormat.Hosts:
            return new HostsFormatter(options);
        case OutputFormat.Dnsmasq:
            return new DnsmasqFormatter(options);
        case OutputFormat.PiHole:
            return new PiHoleFormatter(options);
        case OutputFormat.Unbound:
            return new UnboundFormatter(options);
        case OutputFormat.JSON:
            return new JsonFormatter(options);
        case OutputFormat.DoH:
            return new DoHFormatter(options);
        case OutputFormat.Adblock:
        default:
            return new AdblockFormatter(options);
    }
}

/**
 * Formats rules to the specified output format
 */
export function formatOutput(
    rules: string[],
    format: OutputFormat,
    options?: FormatterOptions,
): FormatterResult {
    const formatter = createFormatter(format, options);
    return formatter.format(rules);
}
