/**
 * Output format converters for filter lists.
 * Converts adblock-style rules to various output formats.
 */

import { OutputFormat } from '../config/defaults.ts';
import { RuleUtils } from '../utils/RuleUtils.ts';
import { PACKAGE_INFO } from '../version.ts';

/**
 * Options for output formatting
 */
export interface FormatterOptions {
    /** Include header comments */
    includeHeader?: boolean;
    /** Filter list name for headers */
    listName?: string;
    /** IP address to use for hosts format (default: 0.0.0.0) */
    hostsIp?: string;
    /** Include localhost entries in hosts format */
    includeLocalhost?: boolean;
}

/**
 * Result of formatting operation
 */
export interface FormatterResult {
    /** Formatted content as string */
    content: string;
    /** Number of rules included */
    ruleCount: number;
    /** Number of rules skipped (not convertible) */
    skippedCount: number;
    /** Output format used */
    format: OutputFormat;
}

/**
 * Base class for output formatters.
 * Extend this class to create custom output formatters.
 */
export abstract class BaseFormatter {
    /** Formatter options */
    protected readonly options: FormatterOptions;

    /**
     * Creates a new formatter
     * @param options - Formatter options
     */
    constructor(options?: FormatterOptions) {
        this.options = {
            includeHeader: true,
            listName: 'Filter List',
            hostsIp: '0.0.0.0',
            includeLocalhost: false,
            ...options,
        };
    }

    /**
     * Formats rules to the target format
     */
    abstract format(rules: string[]): FormatterResult;

    /**
     * Extracts hostname from an adblock rule
     */
    protected extractHostname(rule: string): string | null {
        // Skip comments and empty lines
        if (!rule || rule.startsWith('!') || rule.startsWith('#')) {
            return null;
        }

        // Skip exception rules
        if (rule.startsWith('@@')) {
            return null;
        }

        // Try to parse as adblock rule
        try {
            const parsed = RuleUtils.loadAdblockRuleProperties(rule);
            if (parsed.hostname && !parsed.whitelist) {
                return parsed.hostname;
            }
        } catch {
            // Not a valid adblock rule
        }

        // Check if it's a plain domain
        if (RuleUtils.isJustDomain(rule)) {
            return rule;
        }

        // Try to extract from simple patterns
        const match = rule.match(/^\|\|([a-z0-9.-]+)\^?$/i);
        if (match) {
            return match[1];
        }

        return null;
    }

    /**
     * Generates a header comment
     */
    protected generateHeader(commentPrefix: string): string[] {
        const lines = [
            `${commentPrefix} ${this.options.listName}`,
            `${commentPrefix} Generated by ${PACKAGE_INFO.name} v${PACKAGE_INFO.version}`,
            `${commentPrefix} Last updated: ${new Date().toISOString()}`,
            '',
        ];
        return lines;
    }
}

/**
 * Formats rules to /etc/hosts format
 */
export class HostsFormatter extends BaseFormatter {
    /**
     * Formats rules to hosts file format
     * @param rules - Array of rules to format
     * @returns Formatter result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        // Add localhost entries if requested
        if (this.options.includeLocalhost) {
            lines.push('127.0.0.1 localhost');
            lines.push('::1 localhost');
            lines.push('');
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`${this.options.hostsIp} ${hostname}`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Hosts,
        };
    }
}

/**
 * Formats rules to dnsmasq format
 */
export class DnsmasqFormatter extends BaseFormatter {
    /**
     * Formats rules to dnsmasq format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`address=/${hostname}/`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Dnsmasq,
        };
    }
}

/**
 * Formats rules to Pi-hole format (domain list)
 */
export class PiHoleFormatter extends BaseFormatter {
    /**
     * Formats rules to Pi-hole domain list format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(hostname);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.PiHole,
        };
    }
}

/**
 * Formats rules to Unbound DNS resolver format
 */
export class UnboundFormatter extends BaseFormatter {
    /**
     * Formats rules to Unbound DNS resolver format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        if (this.options.includeHeader) {
            lines.push(...this.generateHeader('#'));
        }

        lines.push('server:');

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                lines.push(`    local-zone: "${hostname}" always_nxdomain`);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.Unbound,
        };
    }
}

/**
 * Formats rules to JSON format
 */
export class JsonFormatter extends BaseFormatter {
    /**
     * Formats rules to JSON format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const hostnames: string[] = [];
        const allRules: string[] = [];
        let skippedCount = 0;

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            if (!rule || rule.startsWith('!')) {
                continue;
            }

            allRules.push(rule);

            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                hostnames.push(hostname);
            } else if (hostname === null) {
                skippedCount++;
            }
        }

        const output = {
            name: this.options.listName,
            generated: new Date().toISOString(),
            generator: `${PACKAGE_INFO.name} v${PACKAGE_INFO.version}`,
            stats: {
                totalRules: allRules.length,
                uniqueHostnames: hostnames.length,
                skippedRules: skippedCount,
            },
            hostnames,
            rules: allRules,
        };

        return {
            content: JSON.stringify(output, null, 2),
            ruleCount: hostnames.length,
            skippedCount,
            format: OutputFormat.JSON,
        };
    }
}

/**
 * Formats rules to DNS-over-HTTPS blocklist format
 */
export class DoHFormatter extends BaseFormatter {
    /**
     * Formats rules to DNS-over-HTTPS blocklist format
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        const lines: string[] = [];
        let ruleCount = 0;
        let skippedCount = 0;

        const seenHostnames = new Set<string>();

        for (const rule of rules) {
            const hostname = this.extractHostname(rule);
            if (hostname && !seenHostnames.has(hostname)) {
                seenHostnames.add(hostname);
                // DoH format: simple domain list, one per line
                lines.push(hostname);
                ruleCount++;
            } else if (hostname === null && rule && !rule.startsWith('!')) {
                skippedCount++;
            }
        }

        return {
            content: lines.join('\n'),
            ruleCount,
            skippedCount,
            format: OutputFormat.DoH,
        };
    }
}

/**
 * Adblock format passthrough (no conversion)
 */
export class AdblockFormatter extends BaseFormatter {
    /**
     * Formats rules in adblock format (passthrough)
     * @param rules - Array of rules to format
     * @returns Formatted result
     */
    format(rules: string[]): FormatterResult {
        return {
            content: rules.join('\n'),
            ruleCount: rules.filter((r) => r && !r.startsWith('!')).length,
            skippedCount: 0,
            format: OutputFormat.Adblock,
        };
    }
}

/**
 * Constructor type for formatters
 */
export type FormatterConstructor = new (options?: FormatterOptions) => BaseFormatter;

/**
 * Extensible formatter factory with registration pattern.
 * Allows registering custom formatters for new output formats.
 */
export class FormatterFactory {
    private static readonly formatters = new Map<OutputFormat | string, FormatterConstructor>();
    private static readonly defaultFormat: OutputFormat = OutputFormat.Adblock;

    /**
     * Register a formatter for a given output format.
     * Can override built-in formatters or add new ones.
     * @param format - Output format identifier
     * @param formatterClass - Formatter constructor
     */
    static register(format: OutputFormat | string, formatterClass: FormatterConstructor): void {
        FormatterFactory.formatters.set(format, formatterClass);
    }

    /**
     * Unregister a formatter
     * @param format - Output format to unregister
     * @returns true if the format was registered and removed
     */
    static unregister(format: OutputFormat | string): boolean {
        return FormatterFactory.formatters.delete(format);
    }

    /**
     * Check if a format is registered
     * @param format - Output format to check
     */
    static has(format: OutputFormat | string): boolean {
        return FormatterFactory.formatters.has(format);
    }

    /**
     * Get all registered format names
     */
    static getRegisteredFormats(): (OutputFormat | string)[] {
        return Array.from(FormatterFactory.formatters.keys());
    }

    /**
     * Create a formatter instance for the given format
     * @param format - Output format
     * @param options - Formatter options
     * @returns Formatter instance
     * @throws Error if format is not registered
     */
    static create(format: OutputFormat | string, options?: FormatterOptions): BaseFormatter {
        const FormatterClass = FormatterFactory.formatters.get(format);

        if (!FormatterClass) {
            // Fall back to default formatter if unknown format
            const DefaultClass = FormatterFactory.formatters.get(FormatterFactory.defaultFormat);
            if (DefaultClass) {
                return new DefaultClass(options);
            }
            throw new Error(`Unknown format: ${format} and no default formatter registered`);
        }

        return new FormatterClass(options);
    }

    /**
     * Initialize factory with built-in formatters.
     * Called automatically on module load.
     */
    static initialize(): void {
        FormatterFactory.register(OutputFormat.Hosts, HostsFormatter);
        FormatterFactory.register(OutputFormat.Dnsmasq, DnsmasqFormatter);
        FormatterFactory.register(OutputFormat.PiHole, PiHoleFormatter);
        FormatterFactory.register(OutputFormat.Unbound, UnboundFormatter);
        FormatterFactory.register(OutputFormat.JSON, JsonFormatter);
        FormatterFactory.register(OutputFormat.DoH, DoHFormatter);
        FormatterFactory.register(OutputFormat.Adblock, AdblockFormatter);
    }
}

// Initialize built-in formatters on module load
FormatterFactory.initialize();

/**
 * Factory function to create formatters (backward compatible wrapper)
 * @deprecated Use FormatterFactory.create() instead
 */
export function createFormatter(format: OutputFormat, options?: FormatterOptions): BaseFormatter {
    return FormatterFactory.create(format, options);
}

/**
 * Formats rules to the specified output format
 */
export function formatOutput(
    rules: string[],
    format: OutputFormat | string,
    options?: FormatterOptions,
): FormatterResult {
    const formatter = FormatterFactory.create(format, options);
    return formatter.format(rules);
}
