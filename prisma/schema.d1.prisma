// Prisma Schema for Cloudflare D1
//
// This schema is optimized for Cloudflare D1 (SQLite at the edge).
//
// Prerequisites:
//   npm install @prisma/client @prisma/adapter-d1
//
// Generate client:
//   npx prisma generate --schema=prisma/schema.d1.prisma
//
// Create migration:
//   npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.d1.prisma --script > migrations/0001_init.sql
//
// Apply migration:
//   wrangler d1 execute adblock-storage --file=migrations/0001_init.sql

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// ============================================================================
// Storage Entry - Generic key-value storage with metadata
// ============================================================================
//
// Used for arbitrary key-value storage with optional TTL.
// Keys are serialized as path strings (e.g., "cache/filters/source-url").

model StorageEntry {
  id        String   @id @default(cuid())
  key       String   @unique
  data      String   // JSON-serialized data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime?
  tags      String?  // JSON array of tags

  @@index([key])
  @@index([expiresAt])
  @@map("storage_entries")
}

// ============================================================================
// Filter Cache - Cached filter list downloads
// ============================================================================
//
// Dedicated table for filter list caching with source-based lookup.
// Content is stored as JSON array of filter rules.

model FilterCache {
  id        String   @id @default(cuid())
  source    String   @unique // Source URL or path
  content   String            // JSON array of filter rules
  hash      String            // Content hash for validation
  etag      String?           // ETag from server response
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime?

  @@index([source])
  @@index([expiresAt])
  @@map("filter_cache")
}

// ============================================================================
// Compilation Metadata - Build history tracking
// ============================================================================
//
// Records compilation runs for audit and analytics purposes.
// Supports querying by config name to get compilation history.

model CompilationMetadata {
  id          String   @id @default(cuid())
  configName  String
  timestamp   DateTime @default(now())
  sourceCount Int
  ruleCount   Int
  duration    Int      // Duration in milliseconds
  outputPath  String?

  @@index([configName])
  @@index([timestamp])
  @@map("compilation_metadata")
}

// ============================================================================
// Source Snapshot - Point-in-time source state for change detection
// ============================================================================
//
// Stores snapshots of filter list state for change detection.
// The isCurrent field is used to quickly find the latest snapshot.
// Note: SQLite uses INTEGER for boolean (0/1).

model SourceSnapshot {
  id          String   @id @default(cuid())
  source      String
  timestamp   DateTime @default(now())
  contentHash String
  ruleCount   Int
  ruleSample  String?  // JSON array of sample rules for debugging
  etag        String?
  isCurrent   Int      @default(1) // SQLite boolean: 1 = true, 0 = false

  @@unique([source, isCurrent])
  @@index([source])
  @@index([timestamp])
  @@map("source_snapshots")
}

// ============================================================================
// Source Health - Reliability metrics for filter sources
// ============================================================================
//
// Tracks health metrics for each filter list source.
// Used to identify unreliable sources and trigger alerts.

model SourceHealth {
  id                  String   @id @default(cuid())
  source              String   @unique
  status              String   // HealthStatus: healthy, degraded, unhealthy, unknown
  totalAttempts       Int      @default(0)
  successfulAttempts  Int      @default(0)
  failedAttempts      Int      @default(0)
  consecutiveFailures Int      @default(0)
  averageDuration     Float    @default(0)
  averageRuleCount    Float    @default(0)
  lastAttemptAt       DateTime?
  lastSuccessAt       DateTime?
  lastFailureAt       DateTime?
  recentAttempts      String?  // JSON array of recent SourceAttempt records
  updatedAt           DateTime @updatedAt

  @@index([source])
  @@index([status])
  @@map("source_health")
}

// ============================================================================
// Source Attempt - Individual fetch attempt record
// ============================================================================
//
// Log of individual fetch attempts for detailed analytics.
// Note: SQLite uses INTEGER for boolean (0/1).

model SourceAttempt {
  id        String   @id @default(cuid())
  source    String
  timestamp DateTime @default(now())
  success   Int      @default(0) // SQLite boolean: 1 = true, 0 = false
  duration  Int                  // Duration in milliseconds
  error     String?
  ruleCount Int?
  etag      String?

  @@index([source])
  @@index([timestamp])
  @@map("source_attempts")
}
