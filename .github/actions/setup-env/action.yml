name: 'Setup Environment Variables'
description: 'Load environment variables based on branch using the layered .env system'

inputs:
  branch:
    description: 'Git branch name to determine environment'
    required: false
    default: ${{ github.ref_name }}

outputs:
  environment:
    description: 'Detected environment (development, production, or local)'
    value: ${{ steps.detect.outputs.environment }}

runs:
  using: 'composite'
  steps:
    - name: Detect environment from branch
      id: detect
      shell: bash
      run: |
        BRANCH="${{ inputs.branch }}"
        
        # Map branch to environment (same logic as .envrc)
        case "$BRANCH" in
          main)
            ENV="production"
            ;;
          develop|dev)
            ENV="development"
            ;;
          *)
            if [[ -f ".env.$BRANCH" ]]; then
              ENV="$BRANCH"
            else
              ENV="local"
            fi
            ;;
        esac
        
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "Detected environment: $ENV (branch: $BRANCH)"

    - name: Load base .env file
      if: hashFiles('.env') != ''
      shell: bash
      run: |
        if [ -f .env ]; then
          echo "Loading .env..."
          # Parse dotenv format: filter comments/blanks, strip quotes, handle heredoc syntax
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Extract key=value, stripping leading/trailing whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"
            
            # Skip if not a valid assignment
            [[ ! "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]] && continue
            
            key="${line%%=*}"
            value="${line#*=}"
            
            # Strip surrounding quotes (both single and double)
            if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
              value="${BASH_REMATCH[1]}"
            fi
            
            # Write to GITHUB_ENV
            echo "$key=$value" >> $GITHUB_ENV
          done < .env
        fi

    - name: Load environment-specific .env file
      if: hashFiles(format('.env.{0}', steps.detect.outputs.environment)) != ''
      shell: bash
      run: |
        ENV_FILE=".env.${{ steps.detect.outputs.environment }}"
        if [ -f "$ENV_FILE" ]; then
          echo "Loading $ENV_FILE..."
          # Parse dotenv format: filter comments/blanks, strip quotes, handle heredoc syntax
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Extract key=value, stripping leading/trailing whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"
            
            # Skip if not a valid assignment
            [[ ! "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]] && continue
            
            key="${line%%=*}"
            value="${line#*=}"
            
            # Strip surrounding quotes (both single and double)
            if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
              value="${BASH_REMATCH[1]}"
            fi
            
            # Write to GITHUB_ENV
            echo "$key=$value" >> $GITHUB_ENV
          done < "$ENV_FILE"
        fi

    - name: Verify environment loaded
      shell: bash
      run: |
        echo "âœ… Environment loaded: ${{ steps.detect.outputs.environment }}"
        echo "COMPILER_VERSION: $COMPILER_VERSION"
        echo "PORT: $PORT"
